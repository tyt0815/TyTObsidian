# 공통 용어 정리
[[1. Projects/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/Exploit|Exploit]]
# 논문 기본 정보
- 제목(Title): [Sugar: Secure GPU Acceleration in Web Browser](https://dl.acm.org/doi/pdf/10.1145/3296957.3173186)
- 저자(Authors): Zhihao Yao, Zongheng Ma, Yingtong Liu, Ardalan Amiri Sani, Aparna Chandramowlishwara
- 학회/저널(Venue): ASPLOS
- 발표/출판 연도: 2018

# 1. Introduction
- **연구 배경:** 최신 웹 브라우저는 성능 향상을 위해 GPU 가속을 활용하고 있고, 그 과정에서 WebGL이 활용됨
	- 파워포인트, 스프레드 시트 같이 기존에 네이티브 앱을 사용 해야 하던 앱들 조차 웹에서 사용이 가능하도록 서비스가 변화중
	- WebGL은 상위 100개의 웹사이트에서 53% 비율로 사용되고 있으며, 사용자들이 사용하는 브라우저의 96%는 WebGL을 지원하는 브라우저임
- **핵심 문제:** WebGL에 의해 보안 위협에 노출되고 있음
	- 너무 넓은 범위의 [[1. Projects/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/Trusted Computing Base(TCB)|TCB]]를 웹 앱에 노출하고 있음: 
		- TCB는 OS의 복합적인 Graphics plane을 말함(GPU와 이를 가동하는 소프트웨어 스택을 포함)
	- WebGL은 브라우저 부터 GPU 라이브러리, 커널의 GPU 디바이스 드라이버 API들 까지 복합적인 OS [[1. Projects/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/Graphics plane|Graphics plane]]을 노출함
	- WebGL에서 셰이더 프로그래밍을 통해 [[1. Projects/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/DMA|DMA]]을 이용해 메인 메모리에 직접적으로 접근이 가능하기 때문에 브라우저의 웹 앱 [[1. Projects/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/Sandbox|샌드박스]] 기능이 약화됨
- **기존 기술의 한계:**
	- Microsoft는 WebGL의 보안 문제 때문에 초기에는 브라우저에 도입하지 않음
	- WebGL은 ad hoc(필요에 따라 그때그때)방식으로 취약점에 대응해 왔음
		- WebGL을 브라우저내에서 GPU Process라 불리는 분리된 프로세스에 isolate 했음
			- **문제점:** GPU Process 분리는 WebGL 구현체를 샌드박스할 수 있지만, 악성 웹으로 부터 OS의 [[1. Projects/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/Graphics plane|Graphics plane]]을 보호할 순 없음.
		- WebGL API가 호출될때 런타임 security check을 수행함.
			- [[1. Projects/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/Graphics plane|Graphics plane]]의 취약점이 발견되면 security check를 추가
			- 브라우저 WebGL 구현부의 취약점은 직접 패치(보안 업데이트)를 수행
			- **문제점:** 보안 체크와 취약점 패치는 제로데이 취약점을 방어할 수 없음
		- untested GPU 디바이스 드라이버와 라이브러리는 blacklist로 만들어 WebGL 접근을 허용하지 않는다.
			- **문제점:** 블랙리스트는 화이트 리스트 시스템에 대해서는 무용지물임
	- 현재 모든 앱(네이티브 + 웹 앱)과 시스템 서비스(OS Window Manager등)은 단일 물리적 그래픽 플레인(single physical graphics plane, 물리적 GPU, 커널의 device driver 포함)을 사용함 
	  -> 웹앱에 상당한 크기의 TCB를 노출
- **제안:** 
	- ==Sugar(Secure GPU Acceleration)==라는 새로운 operating system solution을 제안
		- 웹 앱에서 사용되는 ==virtual graphics planes==을 구현하기 위해 GPU 가상화를 이용
			- virtual graphics plane은 전용 virtual GPU(vGPU)와 이를 실행하기 위한 모든 그래픽스 스택으로 구성
			- 웹앱 프로레스 내에서 [[1. Projects/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/Sandbox|Sandbox]]되어 진다.
		- 하나의 웹 앱은 하나의 전용 virtual graphics plane이 주어지며, 이는 나머지 시스템으로 부터 완전히 isolated되어 있음
		- OS의 윈도우 매니저, 브라우저 코어 프로세스들과 같은 trusted components는 ==primary graphics plane== 라 불리는 분리된 graphics plane을 사용함
			- primary graphics plane:
			  디스플레이에 독점적인 접근이 가능 하며
			  1. trusted components를 위한 그래픽스 가속을 수행하며
			  2. 다양한 graphics plane에 의해 렌더링된 통합 사용자 인터페이스 (UI)를 보여줌
		- ==Single-GPU Sugar==
			- 하나의 virtualizable GPU를 사용하는 장치를 위한 모델
			- 메인 타겟은 인텔 프로세서의 virtualizable [[Integrated GPU]]를 사용하는 노트북-데스크탑
			- primary graphics plane이 동일한 GPU를 사용하게 됨
		- ==Dual-GPU Sugar==
			- 각각 가상화 가능한 두개의 물리적 GPUs를 사용하는 장치를 위한 모델
			- 메인 타겟은 virtualizable 인텔 내장 GPU에 더해 두번째 GPU를 가진 하이엔드 노트북-데스크탑
			- primary graphics plane이 디스플레이와 연결되어 있는 다른 GPU를 사용하게 됨
			- Single-GPU Sugar에 비해 
			  1. 더 좋은 보안 성능을 제공함(특히 DOS공격에 대해)
			  2. 더 좋은 그래픽 성능 분리를 제공함. 즉 웹앱이 사용하는 WebGL이 야기하는 다른 시스템에서의 성능 저하가 적다는 뜻
		- Sugar가 기존 보다 TCB 노출을 20배 줄일 수 있었음

# 2. Current State of WebGL
## 2.1. Adoption
- **Adoption rate**
	- 채택률 측정 방법
	  1. Chrominum의 HTMLCanvasElementModule::getContext()함수를 수정하여 웹 페이지가 WebGL context(WebGL을 사용하는데 필요)를 호출하는지 감지
	  2. 이 브라우저를 Alexa Top Sites list의 상위 웹사이트를 분석하는데 사용
	  3. 사이트 내 페이지를 랜덤하게 1분간 방문하여 분석. 무작위 방문에 포함되지 않는 몇몇 페이지는 수동으로 방문
	- 분석 결과
	  top-100 사이트중 최소 53%, top-1000 사이트중 최소 29.3%, top-10000 사이트중 최소 16.4%가 WebGL을 사용한 것으로 확인됨
	- 논문 작성 당시 48.8 million 방문자가 WebGL을 지원하는 브라우저를 사용함
- **Used of WebGL**
	- Apple, Microsoft, Google, Facebook, Baidu같은 많은 유명한 웹사이트가 GPU 가속을 위해 WebGL을 사용함.
## 2.2. Security
- National Vulnerability Database(NVD)과 Chrome bug report database를 통해 WebGL의 취약점을 찾았다.
	  ![[1. Projects/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/__Attachments/Pasted image 20250831100853.png]]
	  ![[1. Projects/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/__Attachments/Pasted image 20250831101507.png]]
	- exploits 재현은 세가지에 성공함
	- 실험적 평가는 하나, 나머지는 분석적 평가
# 3. Sugar's Design
![[1. Projects/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/__Attachments/Pasted image 20250831103153.png]]
- **문제**
	- OS가 하나의 물리적 graphics plane을  공유하는 것이 보안 문제의 원인이라 판단. 특히 가장 중요한 GPU 디바이스 드라이버는 OS의 커널에서 실행되기 때문에 매우 취약함
- **Key idea**
	- Graphics plane을 웹 앱을 위해 isolate 하는 것
	  -> TCB 크기를 줄일 수 있음
		- 가상화 가능한 GPU(e.g. 인텔 내장 GPU)를 활용하여 구현
		  단일 GPU가 여러개의 vGPU를 만들어 낼 수 있음
		- 웹 앱 프로세스가 전체 graphics stack을 주소 공간으로 로드함
- **기존 시스템 Flow**
	  1. 웹앱이 브라우저의 GPU Process에 WebGL API을 요청함
	  2. GPU Process가 security check을 수행하고 OpenGL 라이브러리를 사용해 GPU device driver와 통신하여 WebGL texture를 렌더링함
	  3. browser process의 browser's compositor가 GPU Process를 이용해 최종 browser's window와 전체 UI를 결정함
	     1. 웹 앱 프로세스의 compositor 스레드가 웹 앱의 UI를 합성(GPU process에 command를 보냄으로써)
	     2. 브라우저의 compositor가 전체 브라우저 윈도우 content를 합성함
		 ==그림은 단순하게 브라우저 compositor만 표현됨==
- **Primaray graphics plane**
	- OS 윈도우 매니저, GPU 프로세스 같은 브라우저 코어 프로세스, 그 외의 어플리케이션들이 사용하는 graphics plane
	- 디스플레이에 독점적 접근이 가능함

**WebGL texture retrieval in Sugar**
- Sugar에서 웹 앱은 브라우저의 WebGL을 위해 GPU 프로세스를 사용하지 않음 대신 GPU 스레드를 가짐
- GPU 스레드는 웹 앱의 WebGL commands를 실행함
  ->WebGL texture 렌더링

- 웹 앱이 렌더링한 텍스쳐를 GPU 프로세스와 공유하기 위해 그래픽스 버퍼를 전달할 필요가 있음(virtual graphics plane -> primary graphics plane)
- Virtual display를 이용한 방법
  1. 웹 앱의 WebGL 텍스처 렌더링 완료
  2. GPU shader를 통해 텍스처를 virtual display의 framebuffer로 복사
  3. GPU device driver가 virtual display의 framebuffer를 텍스처로 encapsulate->브라우저의 GPU process가 사용 가능해짐

- 앞선 방법은 single에서 사용하는 방법이며, dual의 경우 GPU가 두개라서 다른 테크닉을 사용
	- Linux dma-buf interface를 사용

**Co-rendering the UI**
- dual-gpu sugar에선 병렬적으로 gpu를 활용할 수 있음
	- 웹 앱에서 사용하는 GPU(intel 내장 그래픽 카드)
	- 그 외의 네이티브 앱, OS등에서 사용하는 GPU
- 두 작업을 각각 다른 물리적 GPU에서 처리한 후, 통합해서 디스플레이에 출력 가능

**Single vs Dual**
- Single의 경우, 가상화 가능한 GPU가 있는 기기라면 사용이 가능함
- 추가적인 GPU가 있는 경우 사용가능한 Dual은 추가적인 이점을 제공함
  1. Hanging the GPU를 통한 DOS를 방어할 수 있음
  2. performance isolation을 향상 시킬 수 있음. 즉 웹 앱은 GPU사용에 나머지 GPU  작업이 크게 영향 받지 않음

- 기존의 많은 시스템이 하나는 그래픽에, 하나는 컴퓨팅에 두개의 GPU를 활용함. 혹은 두개의 디스플레이에 연결해 각각의 그래픽을 연산하는데 사용되기도 함
- Sugar는 오직 하나의 그래픽에서 두개의 GPU를 사용함

**Supporting multiple web apps**
- 각각의 웹 앱에 vGPU를 할당함에 따라 다중 웹 앱을 지원할 수 있음
- 하지만 GPU의 vGPU 갯수 상한때문에 무한정으로 만들어 낼 순 없음(현재 3개, 이론적으론 인텔 GPU가 8개까지 지원하긴 함)
- 해결 방안으로 세가지 생각해 둔게 있음
  1. WebGL을 사용하는 웹 앱 갯수를 제한
  2. 유저 선택 화이트 리스트 사이트를 만들어 해당 사이트는 primary graphics plane을 바로 사용(Sugar 사용x)
  3. 모든 웹 앱이 통신하는 별도의 GPU 프로세스에 vGPU를 할당하여 단일 vGPU를 공유하도록 함

## 3.1. Threat Model
- 익명의 개발자에 의해 만들어진 웹 앱들은 신용 불가, 나머지 브라우저등은 신용 가능하다고 가정
- [[Side-channel attacks]]은 방어 할 수 없음

## 3.2. Trusted Computing Base
- WebGL API를 통해 하드웨어 가속을 수행하는 데 관련된 소프트웨어 스택의 권한이 있는 부분. 웹 앱 프로세스(웹 앱 코드의 샌드박스) 외부에 있는 부분을 의미
- 기존 WebGL 아키텍처는 브라우저의 GPU process, OpenGL 및 GPU 라이브러리, GPU device driver가 포함됨
- Sugar는 GPU 가상화 소프트웨어, 프로세스에 vGPU를 연결하기 위한 Sugar의 코드, Sugar에서 사용되는 명령어 디코딩을 위한 KVM의 일부가 포함됨

# 4. vGPU Driver as a Library
- **Straw-man solution**
	- 웹 앱을 virtual machine안에서 실행하며 vGPU에 접근
	- 비슷한 방식이 마이크로소프트 엣지의 윈도우 디펜더 어플리케이션 가드에서 사용되고 있음
	- 이 방식은 브라우저 디자인을 크게 개편해야 한다는 단점이 있음
	- 게다가 CPU와 메모리 가상화는 오버헤드를 발생하기 때문에, 그래픽과 상관없는 테스크에서도 퍼포먼스 저하를 일으킴

- **Sugar**
	- virtual machine 없이 웹앱이 vGPU를 직접 접근 가능함
	- vGPU device driver를 [[User space library]]안에 래핑하였고, 웹 앱의 프로세스의 주소 공간에 링크, 그리고 프로세스에 vGPU 연결
	- 이 방식은 CPU, 메모리 가상화 오버헤드를 피할수 있고, 브라우저의 WebGL stack만 수정하면 된다.

## 4.1. Attaching a vGPU to an Operating System Process
- 인텔 GPU 가상화는 [[Mediated passthrough]] 방식으로, GPU 페이지 테이블과 같은 하드웨어 격리 기능을 활용
- vGPU device driver의 vGPU의 register와 페이지 테이블로 접근은 가상화 계층에서 가로채 예뮬레이션
- 하지만 디바이스 드라이버의 performance critical resource에 대한 접근은 가로채지 않아 고성능 가능

- OS Process가 직접 vGPU를 사용할 수 있도록 한 기법
1. vGPU의 레지스터가 RW권한 없이 프로세스 주소 공간으로 매핑
	  1. vGPU 디바이스 드라이버가 레지스터 접근 -> CPU가 [[Trap]] 발생 -> 커널로 제어 전달
	  2. 커널이 이 요청을 받아서 GPU 가상화 계층에서 필요한 동작을 예뮬레이션
	목적: 웹앱 프로세스가 레지스터를 직접 건드릴 수 없게 하면서, 드라이버는 “자기 장치처럼” 동작하게 함
2. vGPU는 실제 GPU처럼 인터럽트를 발생
	- 웹 앱프로세스의 vGPU 드라이버가 인터럽트를 enable/disable 할 수 있는데
		- disable->커널이 signal을 마스킹(mask)
		- enable->pending signal을 전달(unmask)
	목적: 실제 하드웨어 인터럽트처럼 동작시키면서, **웹앱이 임의로 시스템을 건드리는 것을 방지**
3. vGPU 드라이버가 GPU 페이지 테이블을 프로그래밍 할 수 있게 함
   - 인텔 GPU는 MMU를 가지고 있어 디바이스 드라이버가 DMA를 이용하여 GPU가 메모리에 접근하는 것을 컨트롤할 수 있게해줌
   - 비슷하게, vGPU 드라이버가 페이지 테이블을 업데이트하려고 하면 -> 가상화 계층이 trap 후 [[shadowing]] 수행
	목적: vGPU가 **웹앱 프로세스 메모리만 접근**하도록 안전하게 통제
	
	문제:
	- 일반적인 vGPU 드라이버: **VM 안에서 동작**
	    - 페이지 테이블을 구성할 때 **VM의 물리 주소(physical address)** 사용
	    - GPU virtualization layer가 이 주소를 **시스템 물리 주소(system physical address)** 로 변환
	- 그런데 **Sugar에서는 vGPU 드라이버가 일반 OS 프로세스에서 실행**됨
	    - 프로세스는 **단일 가상 주소 공간**만 존재
	    - 따라서 VM처럼 “물리 주소” 개념이 없음 → 기존 방식 그대로는 page table 구성 불가