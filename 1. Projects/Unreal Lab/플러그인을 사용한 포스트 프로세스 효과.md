[참고](https://illu.tistory.com/1500)
플러그인의 이름을 'LearnShader'라 가정하고 진행한다.
# 플러그인 설정
LearnShader.uplugin 파일에서 `LoadingPhase` 설정을 `"PostConfigInit"`으로 해준다.
```json
{
	"FileVersion": 3,
	"Version": 1,
	"VersionName": "1.0",
	"FriendlyName": "LearnShader",
	"Description": "",
	"Category": "Other",
	"CreatedBy": "",
	"CreatedByURL": "",
	"DocsURL": "",
	"MarketplaceURL": "",
	"SupportURL": "",
	"CanContainContent": true,
	"IsBetaVersion": false,
	"IsExperimentalVersion": false,
	"Installed": false,
	"Modules": [
		{
			"Name": "LearnShader",
			"Type": "Runtime",
			"LoadingPhase": "PostConfigInit"
		}
	]
}
```

LearnShader.Build.cs 파일에서 모듈과 IncludePath를 추가해 준다.
```cs
...

PrivateIncludePaths.AddRange(
	new string[] {
        Path.Combine(GetModuleDirectory("Renderer"), "Private")
    }
	);

...

PrivateDependencyModuleNames.AddRange(
	new string[]
	{
		"CoreUObject",
		"Engine",
		"Slate",
		"SlateCore",
		"Projects",
		"RHI",
		"Renderer",
		"RenderCore"
	}
	);
```

# 구현
 - LearnShader..cpp
```cpp
void FLearnShaderModule::StartupModule()
{
	// 셰이더 소스 폴더 매핑
	FString BaseDir = IPluginManager::Get().FindPlugin(TEXT("LearnShader"))->GetBaseDir();
	FString PluginShaderDir = FPaths::Combine(BaseDir, TEXT("Shaders"));
	if (!AllShaderSourceDirectoryMappings().Contains(PluginShaderDir))
	{
		AddShaderSourceDirectoryMapping("/LearnShader", PluginShaderDir);
	}
}
```
셰이더 소스가 들어있는 폴더를 "/LearnShader"라는 가상의 경로로 매핑하는 과정이다. 즉
"**엔진 경로**/**플러그인 경로**/Shaders" 라는 폴더를 "/LearnShader"라는 경로로 매핑 하는 것이다.

## SceneViewExtensionBase
`FSceneViewExtensionBase`를 상속한 `FMySceneViewExtension` 클래스를 만들어 준다. 실질적으로 렌더링 코드가 작성될 클래스다. 오버라이드된 함수의 이름마다 호출되는 타이밍이 다르다는 것을 알 수 있다.
- MySceneViewExtension.h
```cpp
#pragma once

#include "SceneViewExtension.h"

class LEARNSHADER_API FMySceneViewExtension : public FSceneViewExtensionBase
{
public:
	FMySceneViewExtension(const FAutoRegister& AutoRegister);
	~FMySceneViewExtension();

	virtual void SetupViewFamily(FSceneViewFamily& InViewFamily) override;
	virtual void SetupView(FSceneViewFamily& InViewFamily, FSceneView& InView) override;
	virtual void BeginRenderViewFamily(FSceneViewFamily& InViewFamily) override;

	virtual void PreRenderView_RenderThread(FRDGBuilder& GraphBuilder, FSceneView& InView) override;
	virtual void PreRenderViewFamily_RenderThread(FRDGBuilder& GraphBuilder, FSceneViewFamily& InViewFamily) override;
	virtual void PostRenderViewFamily_RenderThread(FRDGBuilder& GraphBuilder, FSceneViewFamily& InViewFamily) override;	
	virtual void PostRenderBasePassDeferred_RenderThread(
		FRDGBuilder& GraphBuilder,
		FSceneView& InView,
		const FRenderTargetBindingSlots& RenderTargets,
		TRDGUniformBufferRef<FSceneTextureUniformParameters> SceneTextures
	) override;
	virtual void PrePostProcessPass_RenderThread(
		FRDGBuilder& GraphBuilder,
		const FSceneView& InView,
		const FPostProcessingInputs& Inputs
	) override;
};

```

소스코드 부분은 일단 전체를 확인하고, 부분부분 내용을 확인해 보자.
- MySceneViewExtension.cpp
```cpp
#include "Render/MySceneViewExtension.h"
#include "Runtime/Renderer/Private/SceneRendering.h"
#include "PostProcess/PostProcessInputs.h"
#include "PixelShaderUtils.h"

BEGIN_SHADER_PARAMETER_STRUCT(FColorExtractParams, )
	SHADER_PARAMETER(FVector3f, TargetColor)
	SHADER_PARAMETER_RDG_TEXTURE(Texture2D, SceneColorTexture)
	SHADER_PARAMETER_STRUCT_INCLUDE(FSceneTextureShaderParameters, SceneTextures)

	RENDER_TARGET_BINDING_SLOTS()
END_SHADER_PARAMETER_STRUCT()

class FMyTestShaderPS : public FGlobalShader
{
public:
	DECLARE_EXPORTED_SHADER_TYPE(FMyTestShaderPS, Global, )
	using FParameters = FColorExtractParams;
	SHADER_USE_PARAMETER_STRUCT(FMyTestShaderPS, FGlobalShader);

	static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
	{
		return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM5);
	}

	static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
	{
		FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);

		// SET_SHADER_DEFINE(OutEnvironment, YOUR_SHADER_MACRO, 0);
	}
};
IMPLEMENT_SHADER_TYPE(, FMyTestShaderPS, TEXT("/LearnShader/MyTestShader.usf"), TEXT("MainPS"), SF_Pixel);

DECLARE_GPU_DRAWCALL_STAT(ColorMix);

FMySceneViewExtension::FMySceneViewExtension(const FAutoRegister& AutoRegister):
	FSceneViewExtensionBase(AutoRegister)
{
}

FMySceneViewExtension::~FMySceneViewExtension()
{
}

void FMySceneViewExtension::SetupViewFamily(FSceneViewFamily& InViewFamily)
{
}

void FMySceneViewExtension::SetupView(FSceneViewFamily& InViewFamily, FSceneView& InView)
{
}

void FMySceneViewExtension::BeginRenderViewFamily(FSceneViewFamily& InViewFamily)
{
}

void FMySceneViewExtension::PreRenderView_RenderThread(FRDGBuilder& GraphBuilder, FSceneView& InView)
{
}

void FMySceneViewExtension::PreRenderViewFamily_RenderThread(FRDGBuilder& GraphBuilder, FSceneViewFamily& InViewFamily)
{
}

void FMySceneViewExtension::PostRenderViewFamily_RenderThread(FRDGBuilder& GraphBuilder, FSceneViewFamily& InViewFamily)
{
}

void FMySceneViewExtension::PostRenderBasePassDeferred_RenderThread(
	FRDGBuilder& GraphBuilder,
	FSceneView& InView,
	const FRenderTargetBindingSlots& RenderTargets,
	TRDGUniformBufferRef<FSceneTextureUniformParameters> SceneTextures
)
{
}

void FMySceneViewExtension::PrePostProcessPass_RenderThread(
	FRDGBuilder& GraphBuilder,
	const FSceneView& InView,
	const FPostProcessingInputs& Inputs
)
{
	FSceneViewExtensionBase::PrePostProcessPass_RenderThread(GraphBuilder, InView, Inputs);

	checkSlow(InView.bIsViewInfo);
	const FIntRect Viewport = static_cast<const FViewInfo&>(InView).ViewRect;
	const FGlobalShaderMap* GlobalShaderMap = GetGlobalShaderMap(GMaxRHIFeatureLevel);

	// Unreal Insights
	RDG_GPU_STAT_SCOPE(GraphBuilder, ColorMix);
	// Render Doc
	RDG_EVENT_SCOPE(GraphBuilder, "ColorMix");

	// Grab the Scene Texture
	const FSceneTextureShaderParameters SceneTextures = CreateSceneTextureShaderParameters(
		GraphBuilder,
		InView,
		ESceneTextureSetupMode::SceneColor | ESceneTextureSetupMode::GBuffers
	);
	// This is the color that actually has the shadow and the shade
	const FScreenPassTexture SceneColorTexture((*Inputs.SceneTextures)->SceneColorTexture, Viewport);

	// Set global shader data, allocate memory
	FMyTestShaderPS::FParameters* Parameters = GraphBuilder.AllocParameters<FMyTestShaderPS::FParameters>();
	Parameters->SceneColorTexture = SceneColorTexture.Texture;
	Parameters->SceneTextures = SceneTextures;
	Parameters->TargetColor = FVector3f(1.0f, 0.0f, 1.0f);

	// Set RenderTarget and Return Texture
	Parameters->RenderTargets[0] = FRenderTargetBinding(
		(*Inputs.SceneTextures)->SceneColorTexture,
		ERenderTargetLoadAction::ELoad
	);

	TShaderMapRef<FMyTestShaderPS> PixelShader(GlobalShaderMap);
	FPixelShaderUtils::AddFullscreenPass(
		GraphBuilder,
		GlobalShaderMap,
		FRDGEventName(TEXT("Color Mix Pass")),
		PixelShader,
		Parameters,
		Viewport
	);
}

// https://illu.tistory.com/1500
```

먼저 셰이더 파라미터를 선언하는 부분이다. 상수 버퍼를 포함한 셰이더에 필요한 파라미터를 설정하는 부분이다.
```cpp
BEGIN_SHADER_PARAMETER_STRUCT(FColorExtractParams, )
	SHADER_PARAMETER(FVector3f, TargetColor)
	SHADER_PARAMETER_RDG_TEXTURE(Texture2D, SceneColorTexture)
	SHADER_PARAMETER_STRUCT_INCLUDE(FSceneTextureShaderParameters, SceneTextures)

	RENDER_TARGET_BINDING_SLOTS()
END_SHADER_PARAMETER_STRUCT()
```
`BEGIN_SHADER_PARAMETER_STRUCT(구조체 이름, )`으로 시작해서 `END_SHADER_PARAMETER_STRUCT()` 로 끝나는 구조체 이며,
내부에 `SHADER_PARAMETER` 계열의 매크로로 멤버를 선언하면 된다. 
`SHADER_PARAMETER_STRUCT_INCLUDE`의 경우 기존 선언된 셰이더 파라미터를 해당 셰이더 파라미터로 포함 시키는 매크로이며, `RENDER_TARGET_BINDING_SLOTS()` 은 렌더타겟을 바인딩 하는 부분이다.

`FMyTestShaderPS` 클래스를 통해 셰이더 내용을 작성한다.
```cpp
class FMyTestShaderPS : public FGlobalShader
{
public:
	DECLARE_EXPORTED_SHADER_TYPE(FMyTestShaderPS, Global, )
	using FParameters = FColorExtractParams;
	SHADER_USE_PARAMETER_STRUCT(FMyTestShaderPS, FGlobalShader);

	static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
	{
		return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM5);
	}

	static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
	{
		FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);

		// SET_SHADER_DEFINE(OutEnvironment, YOUR_SHADER_MACRO, 0);
	}
};
```

- `DECLARE_EXPORTED_SHADER_TYPE`는 셰이더 유형을 선언하는 데 사용하며, 여기서는 GlobalShader로 선언된다. 동시에, 일부 필수 코드 또한 생성한다.
- `using FParameters = FColorExtractParams;` 를 통해 셰이더 파라미터 별칭을 `FParameters` 로 설정하며, `SHADER_USE_PARAMETER_STRUCT(FMyTestShaderPS, FGlobalShader);` 매크로가 FParameters를 통해 셰이더 파라미터를 정의한다. 여기서, 이 두 조합을 사용 하지 않고 `FColorExtractParams` 구조체 + 추가적인 파라미터로 셰이더 파라미터를 구성할 수 있으니 [[../../4. Archive/Render Lab/Custom Lens Flare|이글]]의 `class FLensFlareRescalePS` 클래스를 참고.
- 

## EngineSubSystem
UEngineSubsystem을 상속하는 UMyEngineSubsystem라는 클래스를 만들어 준다. 서브시스템은 언리얼 엔진의 싱글톤 클래스다.
```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Subsystems/EngineSubsystem.h"
#include "MyEngineSubsystem.generated.h"

class FSceneViewExtensionBase;

UCLASS()
class LEARNSHADER_API UMyEngineSubsystem : public UEngineSubsystem
{
	GENERATED_BODY()
	
public:
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void Deinitialize() override;

private:
	TSharedPtr<FSceneViewExtensionBase, ESPMode::ThreadSafe> CustomSceneViewExtension;
};

```
