[LearnOpenGL - PBR - IBL - Specular IBL](https://learnopengl.com/PBR/IBL/Specular-IBL)
# Specular IBL
이전 장에서는 PBR을 이미지 기반 조명(IBL)과 결합하여 간접적인 난반사(diffuse) 조명 부분으로 사용할 **복사조도 맵(irradiance map)** 을 사전 계산하는 방법을 설정했다. 이번 장에서는 반사 방정식의 스펙큘러(specular) 부분을 다룰 것이다:
![[Attachments/Pasted image 20250324092139.png]]
위 식을 보면, **쿡-토랜스(Cook-Torrance) 모델의 스펙큘러 항**( ksk_sks​ 로 곱해지는 부분)은 적분 내에서 일정하지 않으며, **입사광 방향**뿐만 아니라 **뷰 방향**에도 의존한다.

모든 가능한 입사광 방향과 뷰 방향을 포함하여 이 적분을 해석적으로 풀려고 하면 조합(combinatorial)이 기하급수적으로 증가하여 실시간 계산이 불가능할 정도로 비용이 많이 든다. 이에 대해 **에픽 게임즈(Epic Games)** 는 몇 가지 타협점을 감수하면서도 **실시간 처리가 가능한 스펙큘러 사전 컨볼루션 기법**을 제안했으며, 이를 **"스플릿 섬 근사(Split Sum Approximation)"** 라고 한다.

스플릿 섬 근사 방법에서는 반사 방정식의 스펙큘러 부분을 두 개의 독립적인 항으로 나누어 각각 컨볼루션을 수행한 후, PBR 셰이더에서 이 두 항을 결합하여 **스펙큘러 간접 이미지 기반 조명(Specular IBL)** 을 계산할 수 있도록 한다.

이전의 **복사조도 맵**을 사전 컨볼루션했던 것과 유사하게, 스플릿 섬 근사에서는 **HDR 환경 맵**을 입력으로 사용하여 스펙큘러 반사를 컨볼루션해야 한다. 이 개념을 명확히 이해하기 위해, 다시 한번 반사 방정식을 살펴보되 이번에는 스펙큘러 부분에 집중해보자.
![[Attachments/Pasted image 20250324092154.png]]**복사조도 컨볼루션(irradiance convolution)과 동일한 성능상의 이유로**, 우리는 이 적분의 스펙큘러 부분을 실시간으로 해결하는 것이 불가능하며, 실용적인 성능을 기대할 수도 없다. 이상적인 접근 방식은 **이 적분을 사전 계산하여 "스펙큘러 IBL 맵(specular IBL map)"을 생성한 후, 이 맵을 프래그먼트의 노멀로 샘플링하는 것**이다.

그러나 이 과정에서 문제가 발생한다. 복사조도 맵을 사전 계산할 수 있었던 이유는 적분이 **입사 방향( ωi\omega_iωi​ )** 에만 의존했고, 상수인 난반사 알베도(diffuse albedo) 항을 적분 바깥으로 이동할 수 있었기 때문이다. 반면, 이번 적분의 **BRDF(Bidirectional Reflectance Distribution Function)** 는 다음과 같이 표현된다:
![[Attachments/Pasted image 20250324092209.png]]
여기서 적분은 **입사 방향 ωi\omega_iωi​ 뿐만 아니라 출사 방향 ωo\omega_oωo​ 에도 의존**한다. 하지만 **사전 계산된 큐브맵을 두 개의 방향 벡터로 샘플링하는 것은 현실적으로 불가능**하다. 이전 장에서 설명했듯이, 위치 ppp 는 이 문제에서 중요하지 않다. 그렇다고 모든 가능한 ωi\omega_iωi​ 및 ωo\omega_oωo​ 조합에 대해 적분을 사전 계산하는 것은 실시간 렌더링에서 비효율적이다.
**에픽 게임즈(Epic Games)** 는 이 문제를 해결하기 위해 적분을 **두 개의 독립적인 부분으로 분할**하여 사전 계산한 후, PBR 셰이더에서 결합하는 방법을 제안했다. 이를 **"스플릿 섬 근사(Split Sum Approximation)"** 라고 한다.

이 방법에서는 반사 방정식의 스펙큘러 적분을 다음과 같이 두 개의 적분으로 분리한다:
![[Attachments/Pasted image 20250324092243.png]]
첫 번째 적분 **(컨볼루션이 적용된 부분)** 은 **"사전 필터링된 환경 맵(Pre-filtered Environment Map)"** 이라 불리며, 이는 복사조도 맵과 유사한 사전 계산된 환경 컨볼루션 맵이다. 하지만 이번에는 **표면의 거칠기(roughness)를 고려**해야 한다.

**거칠기가 증가할수록, 환경 맵은 더 넓은 영역의 샘플 벡터를 사용하여 컨볼루션되며, 결과적으로 반사가 더 흐려진다**. 이 과정을 위해 각 거칠기 값에 대해 컨볼루션을 수행하며, 그 결과를 **Mipmap 레벨** 에 저장한다. 예를 들어, 특정 환경 맵이 5개의 서로 다른 거칠기 값을 반영하는 **사전 컨볼루션 결과**를 5개의 Mipmap 레벨에 저장한다고 가정하면, 그 구조는 다음과 같다:
![[Attachments/Pasted image 20250324092408.png]]
우리는 **쿡-토랜스 BRDF(Cook-Torrance BRDF)의 법선 분포 함수(NDF, Normal Distribution Function)** 를 사용하여 샘플 벡터와 그 **산란 정도(scattering amount)** 를 생성한다.

그러나 **환경 맵을 컨볼루션하는 과정에서는 뷰 방향(view direction)을 미리 알 수 없다**. 따라서 **Epic Games는 추가적인 근사를 적용하여**, **뷰 방향(및 스펙큘러 반사 방향)이 출력 샘플 방향 ωo\omega_oωo​ 와 동일하다고 가정**한다.

이를 코드로 표현하면 다음과 같다:
```glsl
vec3 N = normalize(w_o);
vec3 R = N;
vec3 V = R;
```
이 방식에서는 **사전 필터링된 환경 컨볼루션 과정에서 뷰 방향을 고려할 필요가 없다**.

그러나 이러한 근사는 **경사(grazing) 각도에서의 스펙큘러 반사가 정확하지 않게 표현되는 문제를 초래**한다. 즉, **비스듬한 각도에서 보는 스펙큘러 반사가 실제보다 약하게 보이는 현상**이 발생한다.

아래 이미지는 이 현상을 보여준다 (**Moving Frostbite to PBR** 논문에서 제공):
![[Attachments/Pasted image 20250324092444.png]]
스플릿 섬 방정식의 두 번째 부분은 스펙큘러 적분의 BRDF 부분과 같다.

만약 들어오는 복사휘도가 모든 방향에서 완전히 흰색(L(p,x) = 1.0)이라고 가정하면, 입력된 거칠기와 법선 n 및 광원 방향 ωi 간의 각도(n⋅ωi)에 대한 BRDF의 응답을 사전 계산할 수 있다.

Epic Games는 사전 계산된 BRDF의 응답을 다양한 거칠기 값과 법선 및 광원 방향 조합에 대해 2D 조회 텍스처(LUT)에 저장하며, 이를 BRDF 적분 맵이라고 한다.

2D 조회 텍스처는 표면의 프레넬 응답을 위한 스케일(빨강) 및 바이어스(초록) 값을 출력하여 스플릿 스펙큘러 적분의 두 번째 부분을 제공한다.

![[Attachments/Pasted image 20250324094815.png]]우리는 평면의 가로 텍스처 좌표(0.0에서 1.0 범위)를 BRDF의 입력 값 n⋅ωi로, 세로 텍스처 좌표를 입력된 거칠기 값으로 취급하여 조회 텍스처를 생성한다.

이 BRDF 적분 맵과 사전 필터링된 환경 맵을 사용하여 두 가지를 결합하면 스펙큘러 적분의 결과를 얻을 수 있다.
```glsl
float lod             = getMipLevelFromRoughness(roughness);
vec3 prefilteredColor = textureCubeLod(PrefilteredEnvMap, refVec, lod);
vec2 envBRDF          = texture2D(BRDFIntegrationMap, vec2(NdotV, roughness)).xy;
vec3 indirectSpecular = prefilteredColor * (F * envBRDF.x + envBRDF.y);
```
이제 Epic Games의 스플릿 섬 근사법이 반사 방정식의 간접 스펙큘러 부분을 대략적으로 어떻게 접근하는지 개요를 살펴보았다. 이제 우리가 직접 사전 컨볼루션된 부분을 구축해 보자.
## Pre-filtering an HDR environment map
환경 맵을 사전 필터링하는 과정은 조도 맵을 컨볼루션하는 방식과 매우 유사하다. 차이점은 거칠기를 고려하고, 사전 필터링된 맵의 MIP 레벨에 점진적으로 거칠어진 반사를 저장한다는 점이다.

우선, 사전 필터링된 환경 맵 데이터를 저장할 새로운 큐브 맵을 생성해야 한다. MIP 레벨을 위한 충분한 메모리를 할당하려면 `glGenerateMipmap`을 호출하여 필요한 메모리를 쉽게 할당할 수 있다.
```glsl
unsigned int prefilterMap;
glGenTextures(1, &prefilterMap);
glBindTexture(GL_TEXTURE_CUBE_MAP, prefilterMap);
for (unsigned int i = 0; i < 6; ++i)
{
    glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB16F, 128, 128, 0, GL_RGB, GL_FLOAT, nullptr);
}
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); 
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

glGenerateMipmap(GL_TEXTURE_CUBE_MAP);
```
사전 필터링된 맵의 MIP 맵을 샘플링할 계획이므로, 최소화 필터를 `GL_LINEAR_MIPMAP_LINEAR`로 설정하여 삼중 선형 필터링(trilinear filtering)을 활성화해야 한다. 기본 MIP 레벨에서 사전 필터링된 스펙큘러 반사는 각 면당 128×128 해상도로 저장된다. 이는 대부분의 반사에 충분하지만, 차량 반사처럼 부드러운 재질이 많은 경우 해상도를 높이는 것이 좋다.

이전 챕터에서는 환경 맵을 컨볼루션할 때 구면 좌표계를 사용하여 반구(Ω)에 균등하게 분포된 샘플 벡터를 생성했다. 이는 조도(Irradiance) 계산에는 적절하지만, 스펙큘러 반사 계산에는 비효율적이다.

스펙큘러 반사의 경우 표면의 거칠기에 따라 빛이 반사 벡터 `r`을 중심으로 좁게 또는 넓게 반사되