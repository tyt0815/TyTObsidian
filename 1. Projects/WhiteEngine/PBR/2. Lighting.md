이전 챕터에서 현실적인 물리 기반 렌더러(PBR)를 구축하기 위한 기초를 다졌습니다.  
이번 챕터에서는 이전에 다룬 이론을 실제 렌더러에 적용하여 **직접 조명(Direct Lighting)** 을 구현하는 방법을 살펴보겠습니다.  
직접 조명에는 점광(Point Light), 방향광(Directional Light), 스포트라이트(Spotlight) 등이 포함됩니다.

우선, 이전 챕터에서 정리한 최종 반사 방정식을 다시 살펴보겠습니다.
![[Attachments/Pasted image 20250313145900.png]]
이제 이 방정식의 대부분을 이해했지만, 여전히 **휘조도(irradiance)** 또는 **장면의 총 방사휘도(total radiance, L)** 를 어떻게 표현할 것인지가 남아 있습니다.  
컴퓨터 그래픽에서는 방사휘도 **L** 는 광원의 방사 플럭스(ϕ) 또는 광에너지를 **주어진 입체각(ω)에서 측정한 값** 으로 해석합니다.  
우리는 입체각(ω)이 무한히 작은 경우를 가정했으므로, **방사휘도는 특정 광선(ray) 또는 방향 벡터(direction vector)에서의 방사 플럭스를 측정한 값** 이 됩니다.

이제 이 개념을 우리가 이전에 배운 조명 모델과 어떻게 연결할 수 있을까요?  
예를 들어, 하나의 **점광(Point Light)** 을 생각해봅시다.  
이 광원이 모든 방향으로 균등하게 빛을 방출한다고 가정하고, 광원의 방사 플럭스(ϕ)가 RGB 삼원색 값으로 (23.47, 21.31, 20.79)라고 가정합니다.  
이 경우, 광원의 **방사 강도(Radiant Intensity)** 는 모든 방향으로 동일합니다.

그러나 특정 표면의 한 점 ppp 를 셰이딩할 때, **반구(hemisphere) Ω의 모든 가능한 입사광 방향** 중에서 **단 하나의 입사 방향** ωi\omega_iωi​ 만이 점광원에서 직접 도달하는 방향이 됩니다.  
즉, 장면에 하나의 점광원만 존재한다고 가정하면, 다른 모든 입사 방향에서 오는 광휘도는 0이 됩니다.
![[Attachments/Pasted image 20250313151625.png]]처음에는 점광원(Point Light)
처음에는 **광 감쇠(light attenuation, 거리 증가에 따른 빛의 감쇠)** 가 점광원에 영향을 미치지 않는다고 가정하면,  
입사광선의 방사휘도는 광원의 위치에 관계없이 동일합니다.  
(단, 입사각의 코사인 값 cos⁡θ 에 의해 방사휘도가 조정되는 경우는 제외)  
이는 점광원이 **방사 강도(Radiant Intensity)** 가 모든 방향에서 일정하기 때문이며,  
결과적으로 점광원의 **방사 강도** 를 **방사 플럭스(Radiant Flux)** 와 동일한 상수 벡터로 모델링할 수 있습니다:  
(23.47,21.31,20.79)(23.47, 21.31, 20.79)(23.47,21.31,20.79).

하지만 방사휘도(L)는 **위치 ppp 를 입력값으로 사용** 하며,  
실제 점광원은 **광 감쇠** 를 고려해야 하므로,  
점광원의 **방사 강도** 는 **표면의 점 ppp 와 광원 사이의 거리** 에 의해 조정됩니다.  
그리고 **원래의 방사휘도 방정식** 에 따라, 결과는 **표면 법선 nnn 과 입사광 방향 ωi\omega_iωi​ 의 내적** 에 의해 추가로 조정됩니다.

이를 보다 실용적인 관점에서 보면, **점광원(Point Light)** 의 경우,  
방사휘도 LLL 는 **광원의 색상** 을 **거리 감쇠** 에 따라 감소시키고,  
**n⋅ωi​ 값** 에 따라 조정하여 최종적으로 **p 에 도달하는 단 하나의 광선 방향 ωi** 에 대해서만 계산됩니다.  
이 광선 방향 ωi 는 **점 p 에서 광원으로 향하는 방향 벡터** 와 같습니다.

코드로 표현하면 다음과 같습니다:
```cpp
vec3  lightColor  = vec3(23.47, 21.31, 20.79);
vec3  wi          = normalize(lightPos - fragPos);
float cosTheta    = max(dot(N, wi), 0.0);
float attenuation = calculateAttenuation(fragPos, lightPos);
vec3  radiance    = lightColor * attenuation * cosTheta;
```
**용어는 조금 다르지만, 이 코드는 우리가 지금까지 구현했던 난반사(Diffuse Lighting) 코드와 거의 동일합니다.**  
즉, 직접 조명(Direct Lighting)의 경우 **단 하나의 광선 방향 벡터** 만이 표면의 방사휘도 계산에 기여하므로,  
기존의 조명 모델과 유사한 방식으로 방사휘도를 계산할 수 있습니다.

>이 가정은 점광원이 무한히 작으며 공간에서 단 하나의 점으로 존재하기 때문에 성립한다. 만약 우리가 면적이나 부피를 가진 광원을 모델링한다면, 하나 이상의 입사 광 방향에서 방사휘도가 0이 아닐 것이다.

다른 유형의 점광원에서도 방사휘도를 계산하는 방법은 유사합니다. 예를 들어, 방향광원(directional light source)은 감쇠(attenuation) 없이 일정한 wi​ 값을 가지며, 스포트라이트(spotlight)의 경우에는 방사 강도(radiant intensity)가 일정하지 않고 스포트라이트의 전방 방향 벡터에 의해 조정됩니다.

이는 또한 표면의 반구 Ω 에 대한 적분 ∫ 으로 다시 연결됩니다. 단일 표면 지점을 셰이딩할 때 기여하는 모든 광원의 위치를 사전에 알고 있기 때문에, 적분을 직접적으로 해결할 필요는 없습니다. 알려진 광원의 개수를 기반으로 총 조사휘도(irradiance)를 직접 계산할 수 있으며, 각 광원은 단 하나의 입사광 방향만이 표면의 방사휘도에 영향을 미치기 때문입니다.

이러한 특성 덕분에 직접광에 대한 PBR은 비교적 간단합니다. 단순히 기여하는 광원들을 순회하면서 계산하면 됩니다. 그러나 이후 IBL(이미지 기반 조명) 챕터에서 환경 조명을 고려할 때는 빛이 모든 방향에서 올 수 있으므로 적분을 수행해야 합니다.
# A PBR surface model
먼저 이전에 설명한 PBR 모델을 구현하는 프래그먼트 셰이더를 작성해 보겠습니다. 이를 위해 표면을 셰이딩하는 데 필요한 관련 PBR 입력값을 가져와야 합니다:
```glsl
#version 330 core
out vec4 FragColor;
in vec2 TexCoords;
in vec3 WorldPos;
in vec3 Normal;
  
uniform vec3 camPos;
  
uniform vec3  albedo;
uniform float metallic;
uniform float roughness;
uniform float ao;
```
우리는 일반적인 정점 셰이더에서 계산된 표준 입력값과 객체 표면에 대한 일정한 재질 속성 집합을 가져옵니다.

그런 다음 프래그먼트 셰이더의 시작 부분에서 모든 조명 알고리즘에 필요한 일반적인 계산을 수행합니다:
```glsl
void main()
{
    vec3 N = normalize(Normal); 
    vec3 V = normalize(camPos - WorldPos);
    [...]
}
```

## Directional Light
이 장의 예제 데모에서는 총 4개의 점광원이 있어 함께 장면의 방사휘도를 나타냅니다. 반사 방정식을 만족시키기 위해 우리는 각 광원에 대해 루프를 돌며 개별 방사휘도를 계산하고, 그것을 BRDF와 광원의 입사 각도로 스케일링하여 기여도를 합산합니다. 우리는 이 루프를 직접 광원에 대해 Ω에 대해 적분을 푸는 과정으로 생각할 수 있습니다. 먼저, 각 광원에 대한 관련 변수를 계산합니다:
```hlsl
vec3 Lo = vec3(0.0);
for(int i = 0; i < 4; ++i) 
{
    vec3 L = normalize(lightPositions[i] - WorldPos);
    vec3 H = normalize(V + L);
  
    float distance    = length(lightPositions[i] - WorldPos);
    float attenuation = 1.0 / (distance * distance);
    vec3 radiance     = lightColors[i] * attenuation; 
    [...]  
}
```
우리는 선형 공간에서 조명을 계산하며 (셰이더 끝에서 감마 보정을 할 예정), 더 물리적으로 정확한 제곱 역 법칙에 따라 광원들을 감쇠시킵니다.

> 물리적으로 정확하지만, 여전히 상수-선형-제곱 감쇠 방정식을 사용하고 싶을 수 있습니다. 이 방정식은 (물리적으로 정확하지 않지만) 광원의 에너지 감소를 더 많이 제어할 수 있게 해줍니다.

