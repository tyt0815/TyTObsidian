# 공통 용어 정리
[[4. Archive/__비공개/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/Exploit|Exploit]]
# 논문 기본 정보
- 제목(Title): [Sugar: Secure GPU Acceleration in Web Browser](https://dl.acm.org/doi/pdf/10.1145/3296957.3173186)
- 저자(Authors): Zhihao Yao, Zongheng Ma, Yingtong Liu, Ardalan Amiri Sani, Aparna Chandramowlishwara
- 학회/저널(Venue): ASPLOS
- 발표/출판 연도: 2018
- DOI: 3296957.3173186

# 1. Introduction
- **연구 배경:** 최신 웹 브라우저는 성능 향상을 위해 GPU 가속을 활용하고 있고, 그 과정에서 WebGL이 활용됨
	- 파워포인트, 스프레드 시트 같이 기존에 네이티브 앱을 사용 해야 하던 앱들 조차 웹에서 사용이 가능하도록 서비스가 변화중
	- WebGL은 상위 100개의 웹사이트에서 53% 비율로 사용되고 있으며, 사용자들이 사용하는 브라우저의 96%는 WebGL을 지원하는 브라우저임
- **핵심 문제:** WebGL에 의해 보안 위협에 노출되고 있음
	- 너무 넓은 범위의 [[4. Archive/__비공개/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/Trusted Computing Base(TCB)|TCB]]를 웹 앱에 노출하고 있음: 
		- TCB는 OS의 복합적인 Graphics plane을 말함(GPU와 이를 가동하는 소프트웨어 스택을 포함)
	- WebGL은 브라우저 부터 GPU 라이브러리, 커널의 GPU 디바이스 드라이버 API들 까지 복합적인 OS [[4. Archive/__비공개/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/Graphics plane|Graphics plane]]을 노출함
	- WebGL에서 셰이더 프로그래밍을 통해 [[4. Archive/__비공개/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/DMA|DMA]]을 이용해 메인 메모리에 직접적으로 접근이 가능하기 때문에 브라우저의 웹 앱 [[4. Archive/__비공개/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/Sandbox|샌드박스]] 기능이 약화됨
- **기존 기술의 한계:**
	- Microsoft는 WebGL의 보안 문제 때문에 초기에는 브라우저에 도입하지 않음
	- WebGL은 ad hoc(필요에 따라 그때그때)방식으로 취약점에 대응해 왔음
		- WebGL을 브라우저내에서 GPU Process라 불리는 분리된 프로세스에 isolate 했음
			- **문제점:** GPU Process 분리는 WebGL 구현체를 샌드박스할 수 있지만, 악성 웹으로 부터 OS의 [[4. Archive/__비공개/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/Graphics plane|Graphics plane]]을 보호할 순 없음.
		- WebGL API가 호출될때 런타임 security check을 수행함.
			- [[4. Archive/__비공개/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/Graphics plane|Graphics plane]]의 취약점이 발견되면 security check를 추가
			- 브라우저 WebGL 구현부의 취약점은 직접 패치(보안 업데이트)를 수행
			- **문제점:** 보안 체크와 취약점 패치는 제로데이 취약점을 방어할 수 없음
		- untested GPU 디바이스 드라이버와 라이브러리는 blacklist로 만들어 WebGL 접근을 허용하지 않는다.
			- **문제점:** 블랙리스트는 화이트 리스트 시스템에 대해서는 무용지물임
	- 현재 모든 앱(네이티브 + 웹 앱)과 시스템 서비스(OS Window Manager등)은 단일 물리적 그래픽 플레인(single physical graphics plane, 물리적 GPU, 커널의 device driver 포함)을 사용함 
	  -> 웹앱에 상당한 크기의 TCB를 노출
- **제안:** 
	- ==Sugar(Secure GPU Acceleration)==라는 새로운 operating system solution을 제안
		- 웹 앱에서 사용되는 ==virtual graphics planes==을 구현하기 위해 GPU 가상화를 이용
			- virtual graphics plane은 전용 virtual GPU(vGPU)와 이를 실행하기 위한 모든 그래픽스 스택으로 구성
			- 웹앱 프로레스 내에서 [[4. Archive/__비공개/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/Sandbox|Sandbox]]되어 진다.
		- 하나의 웹 앱은 하나의 전용 virtual graphics plane이 주어지며, 이는 나머지 시스템으로 부터 완전히 isolated되어 있음
		- OS의 윈도우 매니저, 브라우저 코어 프로세스들과 같은 trusted components는 ==primary graphics plane== 라 불리는 분리된 graphics plane을 사용함
			- primary graphics plane:
			  디스플레이에 독점적인 접근이 가능 하며
			  1. trusted components를 위한 그래픽스 가속을 수행하며
			  2. 다양한 graphics plane에 의해 렌더링된 통합 사용자 인터페이스 (UI)를 보여줌
		- ==Single-GPU Sugar==
			- 하나의 virtualizable GPU를 사용하는 장치를 위한 모델
			- 메인 타겟은 인텔 프로세서의 virtualizable [[4. Archive/__비공개/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/Integrated GPU]]를 사용하는 노트북-데스크탑
			- primary graphics plane이 동일한 GPU를 사용하게 됨
		- ==Dual-GPU Sugar==
			- 각각 가상화 가능한 두개의 물리적 GPUs를 사용하는 장치를 위한 모델
			- 메인 타겟은 virtualizable 인텔 내장 GPU에 더해 두번째 GPU를 가진 하이엔드 노트북-데스크탑
			- primary graphics plane이 디스플레이와 연결되어 있는 다른 GPU를 사용하게 됨
			- Single-GPU Sugar에 비해 
			  1. 더 좋은 보안 성능을 제공함(특히 DOS공격에 대해)
			  2. 더 좋은 그래픽 성능 분리를 제공함. 즉 웹앱이 사용하는 WebGL이 야기하는 다른 시스템에서의 성능 저하가 적다는 뜻
		- Sugar가 기존 보다 TCB 노출을 20배 줄일 수 있었음

# 2. Current State of WebGL
## 2.1. Adoption
- **Adoption rate**
	- 채택률 측정 방법
	  1. Chrominum의 HTMLCanvasElementModule::getContext()함수를 수정하여 웹 페이지가 WebGL context(WebGL을 사용하는데 필요)를 호출하는지 감지
	  2. 이 브라우저를 Alexa Top Sites list의 상위 웹사이트를 분석하는데 사용
	  3. 사이트 내 페이지를 랜덤하게 1분간 방문하여 분석. 무작위 방문에 포함되지 않는 몇몇 페이지는 수동으로 방문
	- 분석 결과
	  top-100 사이트중 최소 53%, top-1000 사이트중 최소 29.3%, top-10000 사이트중 최소 16.4%가 WebGL을 사용한 것으로 확인됨
	- 논문 작성 당시 48.8 million 방문자가 WebGL을 지원하는 브라우저를 사용함
- **Used of WebGL**
	- Apple, Microsoft, Google, Facebook, Baidu같은 많은 유명한 웹사이트가 GPU 가속을 위해 WebGL을 사용함.
## 2.2. Security
- National Vulnerability Database(NVD)과 Chrome bug report database를 통해 WebGL의 취약점을 찾았다.
	  ![[4. Archive/__비공개/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/__Attachments/Pasted image 20250831100853.png]]
	  ![[4. Archive/__비공개/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/__Attachments/Pasted image 20250831101507.png]]
	- exploits 재현은 세가지에 성공함
	- 실험적 평가는 하나, 나머지는 분석적 평가
# 3. Sugar's Design
![[4. Archive/__비공개/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/__Attachments/Pasted image 20250831103153.png]]
- **문제**
	- OS가 하나의 물리적 graphics plane을  공유하는 것이 보안 문제의 원인이라 판단. 특히 가장 중요한 GPU 디바이스 드라이버는 OS의 커널에서 실행되기 때문에 매우 취약함
- **Key idea**
	- Graphics plane을 웹 앱을 위해 isolate 하는 것
	  -> TCB 크기를 줄일 수 있음
		- 가상화 가능한 GPU(e.g. 인텔 내장 GPU)를 활용하여 구현
		  단일 GPU가 여러개의 vGPU를 만들어 낼 수 있음
		- 웹 앱 프로세스가 전체 graphics stack을 주소 공간으로 로드함
- **기존 시스템 Flow**
	  1. 웹앱이 브라우저의 GPU Process에 WebGL API을 요청함
	  2. GPU Process가 security check을 수행하고 OpenGL 라이브러리를 사용해 GPU device driver와 통신하여 WebGL texture를 렌더링함
	  3. browser process의 browser's compositor가 GPU Process를 이용해 최종 browser's window와 전체 UI를 결정함
	     1. 웹 앱 프로세스의 compositor 스레드가 웹 앱의 UI를 합성(GPU process에 command를 보냄으로써)
	     2. 브라우저의 compositor가 전체 브라우저 윈도우 content를 합성함
		 ==그림은 단순하게 브라우저 compositor만 표현됨==
- **Primaray graphics plane**
	- OS 윈도우 매니저, GPU 프로세스 같은 브라우저 코어 프로세스, 그 외의 어플리케이션들이 사용하는 graphics plane
	- 디스플레이에 독점적 접근이 가능함

**WebGL texture retrieval in Sugar**
- Sugar에서 웹 앱은 브라우저의 WebGL을 위해 GPU 프로세스를 사용하지 않음 대신 GPU 스레드를 가짐
- GPU 스레드는 웹 앱의 WebGL commands를 실행함
  ->WebGL texture 렌더링

- 웹 앱이 렌더링한 텍스쳐를 GPU 프로세스와 공유하기 위해 그래픽스 버퍼를 전달할 필요가 있음(virtual graphics plane -> primary graphics plane)
- Virtual display를 이용한 방법
  1. 웹 앱의 WebGL 텍스처 렌더링 완료
  2. GPU shader를 통해 텍스처를 virtual display의 framebuffer로 복사
  3. GPU device driver가 virtual display의 framebuffer를 텍스처로 encapsulate->브라우저의 GPU process가 사용 가능해짐

- 앞선 방법은 single에서 사용하는 방법이며, dual의 경우 GPU가 두개라서 다른 테크닉을 사용
	- Linux dma-buf interface를 사용

**Co-rendering the UI**
- dual-gpu sugar에선 병렬적으로 gpu를 활용할 수 있음
	- 웹 앱에서 사용하는 GPU(intel 내장 그래픽 카드)
	- 그 외의 네이티브 앱, OS등에서 사용하는 GPU
- 두 작업을 각각 다른 물리적 GPU에서 처리한 후, 통합해서 디스플레이에 출력 가능

**Single vs Dual**
- Single의 경우, 가상화 가능한 GPU가 있는 기기라면 사용이 가능함
- 추가적인 GPU가 있는 경우 사용가능한 Dual은 추가적인 이점을 제공함
  1. Hanging the GPU를 통한 DOS를 방어할 수 있음
  2. performance isolation을 향상 시킬 수 있음. 즉 웹 앱은 GPU사용에 나머지 GPU  작업이 크게 영향 받지 않음

- 기존의 많은 시스템이 하나는 그래픽에, 하나는 컴퓨팅에 두개의 GPU를 활용함. 혹은 두개의 디스플레이에 연결해 각각의 그래픽을 연산하는데 사용되기도 함
- Sugar는 오직 하나의 그래픽에서 두개의 GPU를 사용함

**Supporting multiple web apps**
- 각각의 웹 앱에 vGPU를 할당함에 따라 다중 웹 앱을 지원할 수 있음
- 하지만 GPU의 vGPU 갯수 상한때문에 무한정으로 만들어 낼 순 없음(현재 3개, 이론적으론 인텔 GPU가 8개까지 지원하긴 함)
- 해결 방안으로 세가지 생각해 둔게 있음
  1. WebGL을 사용하는 웹 앱 갯수를 제한
  2. 유저 선택 화이트 리스트 사이트를 만들어 해당 사이트는 primary graphics plane을 바로 사용(Sugar 사용x)
  3. 모든 웹 앱이 통신하는 별도의 GPU 프로세스에 vGPU를 할당하여 단일 vGPU를 공유하도록 함

## 3.1. Threat Model
- 익명의 개발자에 의해 만들어진 웹 앱들은 신용 불가, 나머지 브라우저등은 신용 가능하다고 가정
- [[4. Archive/__비공개/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/Side-channel attacks]]은 방어 할 수 없음

## 3.2. Trusted Computing Base
- WebGL API를 통해 하드웨어 가속을 수행하는 데 관련된 소프트웨어 스택의 권한이 있는 부분. 웹 앱 프로세스(웹 앱 코드의 샌드박스) 외부에 있는 부분을 의미
- 기존 WebGL 아키텍처는 브라우저의 GPU process, OpenGL 및 GPU 라이브러리, GPU device driver가 포함됨
- Sugar는 GPU 가상화 소프트웨어, 프로세스에 vGPU를 연결하기 위한 Sugar의 코드, Sugar에서 사용되는 명령어 디코딩을 위한 KVM의 일부가 포함됨

# 4. vGPU Driver as a Library
- **Straw-man solution**
	- 웹 앱을 virtual machine안에서 실행하며 vGPU에 접근
	- 비슷한 방식이 마이크로소프트 엣지의 윈도우 디펜더 어플리케이션 가드에서 사용되고 있음
	- 이 방식은 브라우저 디자인을 크게 개편해야 한다는 단점이 있음
	- 게다가 CPU와 메모리 가상화는 오버헤드를 발생하기 때문에, 그래픽과 상관없는 테스크에서도 퍼포먼스 저하를 일으킴

- **Sugar**
	- virtual machine 없이 웹앱이 vGPU를 직접 접근 가능함
	- vGPU device driver를 [[4. Archive/__비공개/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/User space library]]안에 래핑하였고, 웹 앱의 프로세스의 주소 공간에 링크, 그리고 프로세스에 vGPU 연결
	- 이 방식은 CPU, 메모리 가상화 오버헤드를 피할수 있고, 브라우저의 WebGL stack만 수정하면 된다.

## 4.1. Attaching a vGPU to an Operating System Process
- 인텔 GPU 가상화는 [[4. Archive/__비공개/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/Mediated passthrough]] 방식으로, GPU 페이지 테이블과 같은 하드웨어 격리 기능을 활용
- vGPU device driver의 vGPU의 register와 페이지 테이블로 접근은 가상화 계층에서 가로채 예뮬레이션
- 하지만 디바이스 드라이버의 performance critical resource에 대한 접근은 가로채지 않아 고성능 가능

- OS Process가 직접 vGPU를 사용할 수 있도록 한 기법
1. vGPU의 레지스터가 RW권한 없이 프로세스 주소 공간으로 매핑
	  1. vGPU 디바이스 드라이버가 레지스터 접근 -> CPU가 [[4. Archive/__비공개/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/Trap]] 발생 -> 커널로 제어 전달
	  2. 커널이 이 요청을 받아서 GPU 가상화 계층에서 필요한 동작을 예뮬레이션
	목적: 웹앱 프로세스가 레지스터를 직접 건드릴 수 없게 하면서, 드라이버는 “자기 장치처럼” 동작하게 함
2. vGPU는 실제 GPU처럼 인터럽트를 발생
	- 웹 앱프로세스의 vGPU 드라이버가 인터럽트를 enable/disable 할 수 있는데
		- disable->커널이 signal을 마스킹(mask)
		- enable->pending signal을 전달(unmask)
	목적: 실제 하드웨어 인터럽트처럼 동작시키면서, **웹앱이 임의로 시스템을 건드리는 것을 방지**
3. vGPU 드라이버가 GPU 페이지 테이블을 프로그래밍 할 수 있게 함
   - 인텔 GPU는 MMU를 가지고 있어 디바이스 드라이버가 DMA를 이용하여 GPU가 메모리에 접근하는 것을 컨트롤할 수 있게해줌
   - 비슷하게, vGPU 드라이버가 페이지 테이블을 업데이트하려고 하면 -> 가상화 계층이 trap 후 [[4. Archive/__비공개/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/shadowing]] 수행
	목적: vGPU가 **웹앱 프로세스 메모리만 접근**하도록 안전하게 통제
	
	문제:
	- 일반적인 vGPU 드라이버: **VM 안에서 동작**
	    - 페이지 테이블을 구성할 때 **VM의 물리 주소(physical address)** 사용
	    - GPU virtualization layer가 이 주소를 **시스템 물리 주소(system physical address)** 로 변환
	- 그런데 **Sugar에서는 vGPU 드라이버가 일반 OS 프로세스에서 실행**됨
	    - 프로세스는 **단일 가상 주소 공간**만 존재
	    - 따라서 VM처럼 “물리 주소” 개념이 없음 → 기존 방식 그대로는 page table 구성 불가
	해결:
	- 드라이버 가상, 물리 주소를 둘 다 프로세스 가상 주소로 매핑
		- 가상화 계층이 프로세스 페이지 테이블을 따라가면서
		- vGPU 드라이버가 내놓은 물리 주소를
		- 시스템 물리 주소로 변환한다.
4. 메모리에 vGPU가 DMA를 통해 접근할 수 있는 프로세스 메모리 페이지를 고정
   - 이는 물리적 페이지가 vGPU에 의해 접근가능하다면 swap out되지 않게 해줌
   - 메모리 페이지를 고정하는 것은 OS 메모리 매니저에 부하를 줌
   - 향후, 고정되는 페이지의 수를 최소화 하는 방식을 찾을 예정
1. OpenGL과 Direct Rendering Manager(DRM)라이브러리 같은 User space library가 vGPU 드라이버 라이브러리를 시스템 콜하게 수정
   Sugar 외의 시스템들은 수정되지 않은 버전의 라이브러리를 사용해 primary graphics plane에 접근하게 함
   
## 4.2. Resuing the vGPU Driver Code
- 문제:
	- Sugar는 vGPU 드라이버를 프로세스 내에서 라이브러리 형태로 사용
	- 인텔의 vGPU 드라이버는 OS 커널에서 실행되도록 개발됨
	- 수정하자니 123,000 LoC
- 해결:
	- User Mode Linux(UML)을 사용해 커널 드라이버를 user space로 래핑해서 포팅

- 두 단계로 라이브러리를 위한 메모리를 할당함
	1. UML과 드라이버 초기화가 시행될 때, UML의 SLAB page allocator에 할당되고 드라이버의 호출에 의해 조금 할당되는 고정된 메모리를 할당(e.g., object를 위한 메모리 할당)
	2. Graphics buffer를 위한 큰 메모리 할당은 시스템으로 부터 동적으로 더 많은 메모리를 할당
	- 이러한 방식이 성능과 메모리 공급사이의 타협점이라 생각
	- 시작할때 모든 메모리를 할당하는 것은 메모리 사용이 과하며, 모든 메모리를 동적으로 할당하는 것은 성능에 영향이 간다

## 4.3. Surface Management for vGPU
- graphics plane은 이것을 사용하는 어플간의 프레임버퍼를 컨트롤하고 공유하기 위해 윈도우 매니저를 필요로함
  1. 윈도우 매니저가 어플에게 윈도우와 이 윈도우를 위한 렌더링 가능한 surface를 할당
  2. 어플이 surface에 UI 컨텐츠를 채워 넣음
  3. 윈도우 매니저가 이것들을 합성해 프레임버퍼를 구성함

- 가상 그래픽 플레인도 프레임버퍼의 사용을 제어하기 위해 어떤 형태의 창 관리가 필요함
- 가상 그래픽 플레인은 하나의 웹앱에서 사용되므로, 전체 윈도우 매니저는 필요없음
- 따라서 Sugar에선 베어메탈 surface manager를 사용
  1. 웹 앱당 하나의 fullscreen surface를 하고 
  2. vGPU의 디스플레이로 WebGL 풀스크린 텍스처를 보냄
-  이 방식이 여러 WebGL 텍스처를 사용하면 문제가 생김
  -> 9장에서 자세히

# 5. Browser's Support for Sugar
## 5.1. GPU Thread vs. GPU Process
- 기존 브라우저는 GPU 프로세스라는 GPU 관련 작업을 위한 전용 프로세스 사용
- Sugar는 웹앱이 전용 vGPU를 가지기 때문에 웹앱 프로세스는 GPU 스레드를 생성

- GPU 스레드는 다음과 같은 예외를 제외하고 대부분 GPU 프로세스가 수행하는 것과 동일한 코드를 실행
  1. GPU프로세스가 다른 프로세스로 부터 IPC를 통해 그래픽 작업을 받는것과 달리 GPU 스레드는 같은 프로세스 내의 다른 스레드로 부터 작업을 받음
  2. GPU 프로세스는 디스플레이 관리 작업을 수행하지 않지만 GPU 스레드는 자신의 가상 디스플레이를 설정하고 관리함

- 웹 앱 프로세스에서 다른 스레드와 GPU 스레드를 분리한 이유는, 그래픽 작업에 의해 다른 작업이 미뤄지는 것을 방지하기 위한 성능적 이유임

## 5.2. Rendering Synchronization
- 현재 WebGL 아키텍처는, GPU 프로세스가 종속성에 따라 명령어를 GPU에 제출하는 것을 오케스트레이션함
- Sugar에서는 웹 앱내부에서 WebGL 텍스처가 실행되기 대문에, GPU Process가 작업이 완료됬는지 알 수 없음
  -> 웹 앱 프로세스에서 IPC 통신으로 GPU process에 WebGL 텍스처가 렌더링 되고 vGPU 디스플레이에 포스트된 것을 알림

# 6. Implementation and Prototype
- 구현 구성
	- 인텔 vGPU 드라이버 라이브러리
	- 인텔 GPU 가상화 레이어
	- Mesa(OpenGL 구현 오픈소스)
	- DRM 라이브러리
	- Chromium browser
- vGPU 드라이버와 가상화 레이어는 인텔 드라이버 위에 빌드함(인텔 가상화 지원 사용, Intel GVT-g: 2016-Q3 release of KVMGT). Linux kernel version 4.3.0
- Mesa 버전 12.0.6과 DRM 버전 2.4.70 위에 라이브러리를 빌드하였고, Sugar는 Chromium 버전 58.0.3023.0을 지원함

- 4.1.에서 설명된 것 처럼, vGPU를 프로세스에 붙이기 위해 인텔 GPU 가상화를 지원하였고, 이것은 vGPU 드라이버가 vGPU 레지스터와 몇몇 보호된 메모리 영역에 접근을 trap하고 emulate하는 것을 요구함
- [[KVM]]의 x86 instruction decoder로 trapped accesses를 디코딩함

- 인텔 코어 i7-5775C 프로세스 사용(Iris Pro Graphics 620가 내장됨)
- 다른 인텔 GPU도 가상화만 지원한다면 쉽게 Sugar를 사용할 수 있을 것으로 예상됨
- 16GB 메모리, 500GB SSD, 27인치 디스플레이, ASRock Z97 Extreme4 motherboard
- Dual-GPU Sugar에선 Radeon R9 290 외장 GPU 사용
- 충분히 좋은 외장 GPU를 사용해주는 것이 좋음 

**EGL vs GLS**
- Chromium은 리눅스에서 GLX 프레임워크를 사용하는데, Intel vGPU 프레임 버퍼 read-back 구현은 EGL 프레임워크를 사용
- Chromium이EGL을 사용하도록 바꿧지만, EGL은 고프레임에서 visual choppiness을 보이기 때문에 향후 GLS가 지원되도록 하여 EGL을 대체할 것
**GPU and display configurations**
- Single-GPU Sugar: 인텔 GPU의 VGA포트로 디스플레이에 연결
- Dual-GPU Sugar: BIOS세팅에서 라데온 GPU를 기본 GPU로 설정, "iGPU Multi-Monitor"옵션을 두 GPU에서 enable로 설정. 라데온 GPU의 VGA 포트를 디스플레이에 연결
**Chromium build options**
- 구글의 Chromium Release 버전 빌드 가이드를 따름
- WebGL performance 향상을 위해 “dcheck_always_on”옵션(런타임 assertions를 수행)을 껐음
# 7. Evaluation
## 7.1. Security
**TCB analysis**
![[4. Archive/__비공개/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/__Attachments/Pasted image 20250902095422.png]]**Failure domain analysis**
- 20개의 취약점중 다음 갯수만큼 보호할 수 있음
	- 싱글은 17개
	- 듀얼은 19개

- 아래와 같은 이유로 취약점을 보호할 수 있었음
	1. 웹 앱 프로세스내의 취약한 코드를 모두 샌드박스함
	2. GPU 메모리 가상화로 웹앱으로 부터 GPU 메모리 고립시킴

- 듀얼이 싱글에 비해 극복한 부분은 GPU hang problem임
- 둘 다 해결할 수 없었던 부분은 Table 1.의 #8 문제임.
- 이 문제는 3.1.에서 언급된 timing side-channel 취약점임

- 표의 취약점 중 세가지 취약점에 대한 추가 설명
1. #12
   - GPU 프로세스의 셰이더 컴파일러 버그로 인해 시스템 사용자 이름과 브라우저의 실행 파일 시스템 경로가 유출되는 취약점
   - 컴파일러는 OpenGL 라이브러리의 일부이므로 SUgar는 셰이더 컴파일러를 웹앱 프로세스로 이동
   - 이 방만으로 문제 해결x. but 웹 앱 프로세스를 적절히 샌드박싱 및 시스템 정보에 대한 액세스를 방지하면 효과적일 수 있음
1. #16, #20
   - GPU 장치 드라이버가 시간 초과 감지 및 복구(TDR) 작업을 트리거하여 GPU 하드웨어 재설정
   - TDR이 종종 오류가 발생해 커널 패닉 또는 시각적 부작용을 초래
   - 듀얼은 UI를 멈추는 것을 막을 순 있지만, 중단된 GPU가 TDR을 트리거 하므로 TDR 버그로 인한 문제가 발생 가능
   - 향후 듀얼에서 이 문제를 두가지 방식으로 해결할 계획
     1. 중단 후 시스템이 GPU 재설정을 거부-> primary graphics plane을 계속 사용 가능하지만 Sugar는 사용 불가
     2. TDR작업을 User space로 이동해 최소한 커널 패닉 가능성을 없애는 방안

## 7.2. Performance
![[4. Archive/__비공개/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/__Attachments/Pasted image 20250902123838.png]]
- Blob1: (1, 16^3) -> 블롭 1, 복셀 16^3 
- 모든 실험에서 vGPU의 기본 메모리 사이즈를 사용함
   - 메모리 사이즈는 실험 2에서 바꿔가며 비교하여 설정
   - CPU visible 64MB, CPU non-visible 128MB로 설정
- Sugar는 EGL을 사용하지만 Baseline의 경우 Chromium이 기본으로 GLX를 사용하기 때문에 GLX를 사용

| 구성               | Web app process               | GPU process | 이유                               |
| ---------------- | ----------------------------- | ----------- | -------------------------------- |
| Baseline         | N/A                           | Mesa 12.0.6 |                                  |
| Single-GPU Sugar | Mesa 12.0.6<br>(Sugar 기반 커스텀) | Mesa 17.0.7 | Dual 모델과 형평성을 위해                 |
| Dual-GPU Sugar   | Mesa 12.0.6<br>(Sugar 기반 커스텀) | Mesa 17.0.7 | 사용한 외부 GPU(라데온)이 12.0.6을 지원하지 않음 |

**Expreiment 1: Sugar's performance**
- 60 fps를 보여주는 작업에서 Sugar도 60fps를 넘음
- 60 fps 이하 똑은 근접한 경우 Sugar는 baseline과 비교해 경쟁력 있는 성능을 보여줌
- 결론: Sugar는 기존과 비슷한 유저 경험을 제공 할 수 있다

- 높은 프레임레이트에서 Sugar가 낮은 성능을 보이는 이유는 GPU 가상화 때문으로 추측->GPU 가상화 의 성능이 좋아지면 Sugar의 성능도 좋아짐
- 그 외 추측되는 원인
  1. 인터럽트
  2. WebGL 텍스처를 가상 디스플레이로 포스트 할때 추가로 GPU 사용
- 전자는 더 빠른 인터럽트 메커니즘으로 해결 가능, 후자는 300FPS 기준으로 7%정도 오버헤드를 차지


**Experiment 2: vGPU memory size**
![[4. Archive/__비공개/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/__Attachments/Pasted image 20250902135330.png]]
- 메모리가 너무 낮은 경우와 너무 높은 경우 성능 하락 발생
	- 낮은 경우: 메모리 경합으로 추측
	- 높은 경우: 메모리 고정비용으로 추측
- 최종적으로 64/128 선택

**Experiment 3: supporting multiple web apps**
![[4. Archive/__비공개/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/__Attachments/Pasted image 20250902140134.png]]
- 3개 웹앱을 사용할때 GPU의 CPU-visible memory를 32로 낮춤
**Experiment 4: performance isolation**
![[4. Archive/__비공개/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/__Attachments/Pasted image 20250902140142.png]]
# 8. Related Work
**Browser security & web app isolation**
- 다른 솔루션들은 untrusted web app으로 부터 브라우저와 시스템을 보호하려 함
	- picoprocess, exokernel browser, virtual machine 안으로 샌드박싱
	- 브라우저 TCB 줄이기
- Xax와 Native Client는 각 각 하드웨어 보호 매커니즘과 소프트웨어 fault isolation을 이용해 브라우저에서 naitve code를 안전하게 실행할 수 있다.

**User space I/O**
- Sugar는 사용자 공간 웹 앱 프로세스가 vGPU를 직접 사용할 수 있도록 허용->모든 사용자 공간 I/O솔루션과 관련 있음
- Arrakis and IX은 네트워크와 스토리지 스택의 컨트롤과 데이터 plane을 분리하고 가상화된 I/O 디바이스를 활용하여 사용자 곤간에서 데이터 플레인을 실행->Sugar는 GPU에 집줒하고 웹 브라우저와 결합됨
**Secure UI embeddings**
- AdSplit, AdDroid, LayerCake, SchrodinText는 secure embdding된 UI 인터페이스를 보여줌
- 하이레벨 관점에서 UI의 다양한 부분을 isolation으로 렌더링하는 Sugar와 유사->Sugar는 GPU에 초점, GPU 가상화 활용
**Library operating systems and other sandboxes**
- Exokernel, Drawbridge같은 라이브러리 OS는 Operating system management components를 어플리케이션의 프로세스 주소 공간에서 라이브러리 형태로 실행되어 보안을 향상
- Sugar도 GPU에 대해 exokernel 디자인으로 볼 수 있음
- Haven은 인텔 Software Guard Extension(SGX)를 사용해 어플을 untrusted cloud로 부터 보호하고 라이브러리 OS를 [[4. Archive/__비공개/정보 보안 논문 맛보기/Sugar - Secure GPU Acceleration in Web Browser/enclave]]에서 사용함
**GPU virtualization**
- Cells는 모바일 기기에서 OS 수준의 가상화를 지원하고 다수의 가상 폰에서 가상화를 통한 GPU 보안 공유를 지원함
- Paradice는 GPU를 포함한 I/O 디바이스를 UNIX device file boundary를 사용하여 준 가상화를 지원
- Sugar는 기존의 GPU 가상화 솔루션을 웹앱의 GPU 보안 접근에 사용
**Application's direct access to hardware**
- nonekernel은 어플이 장치에 직접 접근하도록 함
- GPU 가상화와 결합해, nonkernel은 vGPU를 각기 다른 어플에 할당할 수 있음
- nonekernel은 브라우저의 지원이 없으면 사용할 수 없음
- Dune은 어플이 가상화 하드웨어 확장에 직접 접근할 수 있도록 함
- 유사하게, Sugar는 어플이 vGPU로 직접 접근을 할 수 있게 해줌
**Alternative device driver designs**
- 브라우저에서 GPU 접근의 보안 문제는 주로 GPU 커널 디바이스 드라이버의 취약점임
- microkernel은 디바이스 드라이버를 유저 스페이스로 옮김
- SUD, Microdriver, Glider는 드라이버의 부분 혹은 전체를 유저 스페이스로 옮김
- 이를 위해 SUD와 Glider는 UML을 사용하였고 Sugar 또한 그럼
- Levasseur et al.은 디바이스 드라이버를 더 효과적인 isolation을 위해 VM으로 옮김
- Nooks, SafeDrive는 드라이버를 커널에 그대로 두고 각각 런타임, language 솔루션을 사용해 취약점에 대응함
- Sugar는 vGPU 디바이스 드라이버를 라이브러리로써 실행하고 효과적으로 브라우저내의 웹앱과 통합할 수 있음을 보여준 첫번째 사례임

# 9. Limitations and Future Work
**Multiple WebGL textures in one web app**
- 현재 Sugar는 WebGL 텍스처 하나가 가상 디스플레이의 전체 프레임버퍼를 차지하기 때문에 웹 앱당 하나의 텍스처밖에 사용할 수 없음
- 이 프레임버퍼를 공유함으로써 다수의 텍스처를 사용할 수 있게 할 예정
**Tearing effect**
- 높은 프레임레이트에서 연속적으로 렌더링 되는 프레임에 tearing effect가 나타나는 문제
- 가상 디스플레이가 GPU프로세스에서 리드백하고, WebGL 텍스처 포스팅을 연속적으로 하는 것이 겹쳐서 그럼
- 가상 디스플레이에 다수의 프레임버퍼를 사용해 해결할 예정
**Other GPU Virtualization Solutions**
- 인텔 GPU 가상화를 선택한 것은 대부분의 컴퓨터에서 사용하기 때문
- NVIDIA와 AMD는 더 좋은 성능과 isolation을 제공하는 GPU가상화가 있지만, 대체로 서버를 위해 맞춰져 있어 가정용 컴퓨터에서는 잘 사용 되지 않음
- 이러한 GPU를 지원하려면 해당 드라이버를 사용자 공간으로 포팅하는데 많은 엔지니어링작업이 필요
**Native apps**
- Sugar는 보안 GPU 가속을 untrusted native app에도 제공할 수 있음
- 이는 OS 윈도우 매니저를 수정하여 vGPU로 부터 앱의 렌더링된 텍스처를 드러나게 해야함: 브라우저의 GPU 프로세스가 웹 앱의 WebGL 텍스처를 드러나게 하는 것과 유사함

# 10. Conclusions
- Sugar라는 operating system solution로 웹앱을 위한 향상된 보안 GPU 가속을 제공함
- 웹앱을 위한 전용 그리고 isolated virtual graphics plane을 모던 GPU 가상화 솔루션으로 구현
- Sugar가 웹앱으로 노출되는 TCB를 줄이고 WebGL에서 보고된 다양한 취약점을 없앨 수 있음
- Sugar의 성능이 좋고, 비슷한 유저 경험을 제공함